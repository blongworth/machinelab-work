---
title: Calibrate pH sensor
format: html
editor: source
---

TODO: plot seaphox with lecs before and after calibration (confirm timestamps)

Apply ph calibration to entire dataset

save parquet

```{r}
library(arrow)
library(tidyverse)
library(janitor)
library(readxl)
library(mlabtools)
library(dygraphs)
#library(clock)
#library(data.table)

data_dir <- "data/processed/"
```

Open dataset

```{r}
ds <- open_dataset(paste0(data_dir, "adv_all_filt.parquet"))
```


# Calibration

Calibrate full data set

add col for calibration periods

```{r}
ds <- ds |> 
  mutate(ph_group = if_else(timestamp > "2023-12-22 06:45:00", 1L, 0L))
```

## Seaphox calibration data

### Jul calibration

```{r}
sp_jul <- read_excel("data/SeapHOx Data/Seaphox_LECS_072423.xlsx") |> 
  clean_names() |> 
  select(timestamp = date_time_utc_04_00,
         pH = internal_p_h_p_h,
         temp = p_h_temperature_celsius,
         pressure = pressure_decibar,
         sal = salinity_psu,
         oxygen = oxygen_ml_l)
sp_jul <- filter(sp_jul, timestamp > "2023-07-24 17:00:00",
                 timestamp < "2023-08-09 13:00:00")
```

check alignment with LECS data

```{r}
lecs_jul <- ds |> 
  select(timestamp, pH) |> 
  filter(timestamp > "2023-07-24 17:00:00",
                 timestamp < "2023-08-09 13:00:00") |> 
  mutate(timestamp = floor_date(timestamp, unit = "minutes")) |> 
  group_by(timestamp) |> 
  summarize(LECS_pH = mean(pH)) |> 
  collect()
  
ggplot(sp_jul, aes(timestamp, pH)) +
  geom_line() +
  geom_line(data = lecs_jul, aes(timestamp, LECS_pH), color = "blue")
```

### Oct calibration

Removing this for now, because the seaphox data is funky

```{r}
sp_oct <- read_excel("data/SeapHOx Data/Seaphox_LECS_10052023.xlsx") |> 
  clean_names() |> 
  #mutate(time = mdy_hms(date_time_utc_04_00,
  #                         tz = "UTC")) |> 
  select(timestamp = date_time_utc_04_00,
         pH = internal_p_h_p_h,
         temp = p_h_temperature_celsius,
         pressure = pressure_decibar,
         sal = salinity_psu,
         oxygen = oxygen_ml_l)

sp_oct <- filter(sp_oct, timestamp > "2023-10-19 18:00:00",
                 timestamp < "2023-11-02 08:00:00")
```

## Nov calibration

```{r}
sp_nov <- read_excel("data/SeapHOx Data/Seaphox_LECS_111523.xlsx") |> 
  clean_names() |> 
  #mutate(time = mdy_hms(date_time_utc_04_00,
  #                         tz = "UTC")) |> 
  select(timestamp = date_time_utc_04_00,
         pH = internal_p_h_p_h,
         temp = p_h_temperature_celsius,
         pressure = pressure_decibar,
         sal = salinity_psu,
         oxygen = oxygen_ml_l)

sp_nov <- filter(sp_nov, timestamp > "2023-11-15 16:00:00",
                 timestamp < "2023-11-21 09:30:00")
```

## December calibration

before sensor change

```{r}
sp_dec <- read_excel("data/SeapHOx Data/Seaphox_LECS_120723.xlsx") |> 
  clean_names() |> 
  #mutate(time = mdy_hms(date_time_utc_04_00,
  #                         tz = "UTC")) |> 
  select(timestamp = date_time_utc_04_00,
         pH = internal_p_h_p_h,
         temp = p_h_temperature_celsius,
         pressure = pressure_decibar,
         sal = salinity_psu,
         oxygen = oxygen_ml_l)

sp_dec <- filter(sp_dec, timestamp > "2023-12-08 06:00:00",
                 timestamp < "2023-12-14 14:00:00")
```

## Jan calibration

Note that seapHOx data have UTC timestamps

```{r}
sp_jan <- read_seaphox("data/SeapHOx Data/Seaphox_LECS_122223.csv") 

sp_jan <- filter(sp_jan, timestamp > "2023-12-22 14:00:00",
                 timestamp < "2024-01-03 10:00:00")
```

# Calibration

do regression of temp and ph_counts on seaphox ph and add to df

To speed up, modify `generate_ph_model`, work with Arrow data, and parallelize

```{r}
jul_coef <- generate_ph_model(sp_jul, ds)
oct_coef <- generate_ph_model(sp_oct, ds)
nov_coef <- generate_ph_model(sp_nov, ds)
dec_coef <- generate_ph_model(sp_dec, ds)
jan_coef <- generate_ph_model(sp_jan, ds)
```

## Smooth between regressions

Smoothly transition between fit parameters to account for drift

make df with timestamp and cal factors
don't use jan cal (do stepwise due to sensor change)

```{r}
cals <- list(sp_jul, sp_oct, sp_nov, sp_dec)
coefs <- bind_rows(jul_coef, oct_coef, nov_coef, dec_coef)
cal_time <- map(cals, ~mean(.x$timestamp))
cal_time <- do.call(c, cal_time)
cal_df <- bind_cols(as.data.frame(cal_time), coefs)
```

Apply linear fit between calibrations

convert to dataframe

```{r}
df <- collect(ds)
```


```{r}
i_ap_fun <- approxfun(cal_df$cal_time, cal_df$`(Intercept)`, rule = 2)
c_ap_fun <- approxfun(cal_df$cal_time, cal_df$lecs_ph_counts, rule = 2)
t_ap_fun <- approxfun(cal_df$cal_time, cal_df$lecs_temp, rule = 2)
i_fit <- i_ap_fun(df$timestamp)
c_fit <- c_ap_fun(df$timestamp)
t_fit <- t_ap_fun(df$timestamp)
```

```{r}
df_cal <- df %>% 
  mutate(
    ph_i = i_fit,
    ph_c = c_fit,
    ph_t = t_fit,
    #ph_i = if_else(ph_group == 1, jan_coef[1], ph_i),
    #ph_c = if_else(ph_group == 1, jan_coef[2], ph_c),
    #ph_t = if_else(ph_group == 1, jan_coef[3], ph_t),
    ph_i = replace(ph_i, ph_group == 1, jan_coef[1]),
    ph_c = replace(ph_c, ph_group == 1, jan_coef[2]),
    ph_t = replace(ph_t, ph_group == 1, jan_coef[3]),
    pH = ph_i + ph_c * ph_counts + ph_t * temp)
```


```{r}
ds_cal <- df_cal |> 
  select(-c(ph_group, ph_i, ph_c, ph_t)) |> 
  arrow_table() 
ds_cal |> 
  write_dataset(paste0(data_dir, "adv_all_filt_cal.parquet"))
```

Calculate per-hour mean


with duckdb. also doesn't work with timezone!

```{r}
adv_data_mean <- ds |>
  to_duckdb() |> 
  group_by(year = year(timestamp), month = month(timestamp), day = day(timestamp), hour = hour(timestamp)) |> 
  summarise(across(-timestamp, 
                   ~ mean(.x, na.rm = TRUE))) |> 
  mutate(timestamp = make_datetime(year, month, day, hour)) |> 
  ungroup()
adv_data_mean

  
```

```{r}
dygraph(select(adv_data_mean, timestamp, pH))
```

```{r}
dygraph(select(adv_data_mean, time, ph_counts))
```

```{r}
dygraph(select(adv_data_mean, time, pH))
```

```{r}
sp <- bind_rows(sp_jul, sp_oct, sp_nov, sp_dec, sp_jan)

select(sp, time, pH) |> dygraph()
```

