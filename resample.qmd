---
title: "Resample LECS ADV timeseries"
format: html
editor: source
---

* Resample filtered and calibrated data to hourly and every minute
* Resample to 4Hz

impute missing points. Acceptable number?

How to divide up remaining points and group

* group between gaps
* group these groups by 1h or 15 min
* run flux on each group

```{r}
library(tidyverse)
library(arrow)
# library(tictoc)
library(imputeTS)

options(digits.secs = 6)

data_dir <- "data/processed/surface"
```

```{r}
ds <- open_dataset(file.path(data_dir, "lecs_adv_cal.parquet"))
```

resample to hourly

```{r}
ds_hourly <- ds |> 
  select(-c(year, month)) |> 
  mutate(timestamp = floor_date(timestamp, "hour")) |> 
  group_by(timestamp) |> 
  summarise(across(everything(), 
                   ~ mean(.x, na.rm = TRUE))) |> 
  ungroup()

ds_hourly |> 
  collect() |> 
  data.table::fwrite(file.path(data_dir, "lecs_adv_hourly.csv"))

write_dataset(ds_hourly, 
              file.path(data_dir, "lecs_adv_hourly.parquet"))
```

resample to minute

```{r}
ds_minute <- ds |> 
  select(-c(year, month)) |> 
  mutate(timestamp = floor_date(timestamp, "minute")) |> 
  group_by(timestamp) |> 
  summarise(across(everything(), 
                   ~ mean(.x, na.rm = TRUE))) |> 
  ungroup()

ds_minute |> 
  collect() |> 
  data.table::fwrite(file.path(data_dir, "lecs_adv_minute.csv"))

write_dataset(ds_minute, 
              file.path(data_dir, "lecs_adv_minute.parquet"))
```

Resample to 4Hz and impute missing data

Impute full timeseries for up to 4 missing samples at 16Hz. Need to populate NA's first!
Also takes a loooooong time. Not doing this way for now.

```{r, eval=FALSE}
df_imp <- ds %>% 
  collect() %>% 
  mutate(across(-timestamp, \(x) na_locf(x, maxgap = 4)))
```

resample to 4Hz

```{r}
ds_4hz <- ds |> 
  select(-c(year, month)) |> 
  mutate(timestamp = floor_date(timestamp, ".25 sec")) |> 
  group_by(timestamp) |> 
  summarise(across(everything(), 
                   ~ mean(.x, na.rm = TRUE))) |> 
  ungroup() |> 
  compute()
```

create complete 4Hz timeseries and join to add NA's for missing data

```{r}
# df_4hz <- ds_4hz |> 
#   arrange(timestamp) |> 
#   collect()

st_et <- ds_4hz |> 
  select(timestamp) |> 
  summarize(time_min = min(timestamp), 
            time_max = max(timestamp) 
  ) |> 
  collect()

ts_4hz <- seq(from = st_et$time_min, to = st_et$time_max, by = 0.25) 

ds_ts_4hz <- tibble(timestamp = ts_4hz) |> 
  arrow_table()

ds_4hz_all <- ds_ts_4hz |> 
  left_join(ds_4hz)
```

```{r}
ds_4hz_all %>% 
  group_by(year = year(timestamp), month = month(timestamp)) %>% 
  write_dataset(file.path(data_dir, "lecs_adv_4hz.parquet"))
```

Impute by interpolation with a max gap of 1sec.

```{r}
df_4hz_all_imp <- ds_4hz_all %>% 
  collect() |> 
  mutate(across(-timestamp, \(x) na_interpolation(x, maxgap = 4)))

df_4hz_all_imp %>% 
  group_by(year = year(timestamp), month = month(timestamp)) %>% 
  write_dataset(file.path(data_dir, "lecs_adv_4hz_imp.parquet"))
```

Add groups representing continuous data

```{r}
df_4hz_imp_grp <- df_4hz_all_imp |> 
  arrange(timestamp) |> 
  mutate(is_gap = is.na(pH_cal) & !is.na(lag(pH_cal, default = NA))) |> 
  mutate(group = cumsum(is_gap) + 1) |> 
  select(-is_gap)
```

remove NA's and write to parquet

```{r}
df_4hz_imp_grp |> 
  drop_na(pressure) |> 
  group_by(year = year(timestamp), month = month(timestamp)) |> 
  write_dataset(file.path(data_dir, "lecs_adv_4hz_imp_grp.parquet"))
```

TODO: divide up big groups

