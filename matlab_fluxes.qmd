---
title: "matlab_fluxes"
format: html
---

```{r}
library(tidyverse)
library(mlabtools)
library(furrr)
library(purrr)
library(arrow)
library(tictoc)
library(patchwork)
library(imputeTS)
library(dygraphs)
library(suntools)

options(digits.secs = 6)

theme_set(theme_classic())
data_dir <- "data/processed/surface"
```

```{r}
ds <- open_dataset(file.path(data_dir, "lecs_adv_4hz_imp_grp_15_mv.parquet/"))
```

## Extract data for flux analysis in matlab

function to save as text file in matlab eddyfluxpHO2v_41 format

```{r}
#' Export LECS data in MATLAB eddyfluxpHO2v_41 format
#'
#' @param data A resampled, imputed LECS data_frame, grouped by gap-free runs
#' @param min_time Remove chunks shorter than `min_time` hours
#' @param data_file Output data filename
#' @param timestamp_file Output gap-free timestamp file
#'
#' @return A list containing the output and timestamp data frames
#' @export
lecs_to_ml <- function(data,
                       min_time = .25, 
                       data_file = NULL, 
                       timestamp_file = NULL) {
  df <- data |>
    mutate(time = as.numeric(difftime(timestamp, min(timestamp),
                                      units = "hours")))
  df_ml <- df |>
    select(time, vx = u, vy = v, vz = w,
           o2 = ox_umol_l_cal, ph = pH_cal, pres = pressure,
           SNR = amp3, corr = corr3) |> 
    # NA's crash Matlab. These should be taken care of better and earlier
    drop_na()
  
  df_ml_ts <- df %>%
    group_by(block) %>%
    summarise(start = min(time),
              end = max(time)) %>%
    ungroup()
  
  # remove last row of times to make shift indexing work
  df_ml_ts <- df_ml_ts[-nrow(df_ml_ts), ]
  
  if (min_time > 0) {
    df_ml_ts <- df_ml_ts |>
      filter(end - start >= min_time)
  }
  if (!is.null(data_file)) {
    write_delim(df_ml, data_file)
  }
  if (!is.null(timestamp_file)) {
    df_ml_ts %>%
      select(start, end) %>%
      write_delim(timestamp_file,
                  col_names = FALSE)
  }
  list(df_ml, df_ml_ts)
}
```

test with one lander position

```{r}
df <- ds %>% 
  filter(lander_position == 9) |>
  arrange(timestamp) |> 
  #head(n = 300000) |> 
  collect() |> 
  
  lecs_to_ml(0.25, "../aec-tests/mltest/outfile1_lecstest.dat", "../aec-tests/mltest/lecstest_timestamps.dat")
```

generate files for all lander positions

```{r}
group_ml <- function(pos, ...) {
  data_path = "data/processed/matlab_input"
  data_file <- file.path(data_path, paste0("lecs_ml_data_", pos, ".dat"))
  timestamp_file <- file.path(data_path, paste0("lecs_ml_timestamps_", pos, ".dat"))
  
  ds |> 
    filter(lander_position == pos) |> 
    arrange(timestamp) |> 
    collect() |> 
    lecs_to_ml(min_time = 0.24, data_file = data_file, timestamp_file = timestamp_file)
}
```

```{r}
pos <- ds |> 
  group_by(lander_position) |> 
  summarize(t0 = min(timestamp),
            n = n()) |> 
  arrange(lander_position) |> 
  collect()
```


```{r, eval=FALSE}
# TODO: parallelize
future_map(1:15, group_ml)
```

Run all fluxes using matlab/eddyflux_batch.m scripted using run_eddyflux.sh

```{r, eval = FALSE}
system("matlab/run_eddyflux.sh")
```

get t0 for all files and convert from decimal hours to UTC timestamps

combine flux data

```{r}
flux_files <- list.files("matlab", pattern = "outfile2Rot_lecs_ml*", full.names = TRUE)
flux <- read_delim(flux_files, id = "file") |> 
  mutate(lander_position = as.integer(str_extract(file, "(\\d{1,2})(?=\\.dat$)"))) |> 
  left_join(select(pos, lander_position, t0)) |> 
  group_by(lander_position) |> 
  mutate(timestamp = as.POSIXct(timemean * 3600, origin = t0, tz = "GMT")) |> 
  arrange(timestamp) |> 
  ungroup()
```

```{r}
write_dataset(flux, file.path(data_dir, "lecs_flux_4hz_rot_fl5.parquet"))
```


```{r}
dygraph(select(flux, timestamp, flux3o2), group = "flux")
```
```{r}
flux |> 
  ggplot(aes(timestamp, flux3o2)) +
  geom_line() +
  geom_hline(yintercept = 0) +
  ylab("O2 Flux [mmol/m2/h]")
  
```


```{r}
dygraph(select(flux, timestamp, vxmean, vymean, vzmean), group = "flux")
```

```{r}
flux |>
  select(timestamp, vxmean, vymean, vzmean) |> 
  # filter(timestamp > "2023-11-28 18:00:00",
  #        timestamp < "2023-11-28 22:00:00") |> 
  pivot_longer(cols = c(vxmean, vymean, vzmean),
               names_to = "axis", values_to = "velocity") |> 
  ggplot(aes(timestamp, velocity)) +
  geom_line() +
  facet_grid(rows = "axis")
```
```{r}
flux |>
  select(timestamp, vxrot, vyrot, vzrot) |> 
  # filter(timestamp > "2023-11-28 18:00:00",
  #        timestamp < "2023-11-28 22:00:00") |> 
  pivot_longer(cols = c(vxrot, vyrot, vzrot),
               names_to = "axis", values_to = "velocity") |> 
  ggplot(aes(timestamp, velocity)) +
  geom_line() +
  facet_grid(rows = "axis")
```

```{r}
dygraph(select(flux, timestamp, vxrot, vyrot, vzrot), group = "flux")
```
```{r}
dygraph(select(flux, timestamp, o2mean), group = "flux")
```


```{r}
dygraph(select(flux, timestamp, SNRmean, correlationmean), group = "flux")
```

```{r}
flux |> 
  select(vxmean, vymean) |> 
  mutate(across(everything(), abs)) |> 
  plot()
```

Diurnal cycle

```{r}
crds <- matrix(c(-70.7003, 41.51875), nrow = 1)

# calculate predicted par from solar azimuth
pred_par <- function(crds, timestamp) {
  altitude <- solarpos(crds, timestamp)[,2]
  altitude <- replace(altitude, altitude <= 0, 0)
  insolation = sin(altitude * pi / 180)
  par = 0.45 * insolation * 4.6 * 1000
  par
}
```

```{r}
flux_h <- flux |> 
  mutate(par = pred_par(crds, timestamp),
         hour = hour(timestamp)) |> 
  group_by(hour) |> 
  summarise(across(everything(), c(mean = mean, sd = sd)))
```


```{r}
o2 <- ggplot(flux_h, aes(hour, flux3o2_mean)) + 
  geom_line() +
  #geom_pointrange(aes(ymin = flux3o2_mean - flux3o2_sd,
  #                    ymax = flux3o2_mean + flux3o2_sd)) +
  geom_hline(yintercept = 0) +
  ylab("O2 Flux [mmol/m2/h]")

par <- ggplot(flux_h, aes(hour, par_mean)) +
  geom_line()

par / o2
```

```{r}
o2 <- ggplot(flux_h, aes(hour, flux3o2stor_mean)) + 
  geom_line() +
  #geom_pointrange(aes(ymin = flux3o2_mean - flux3o2_sd,
  #                    ymax = flux3o2_mean + flux3o2_sd)) +
  geom_hline(yintercept = 0) +
  ylab("O2 Flux [mmol/m2/h]")

par <- ggplot(flux_h, aes(hour, par_mean)) +
  geom_line()

par / o2
```

```{r}
flux_s <- flux |> 
  mutate(par = pred_par(crds, timestamp),
         hour = hour(timestamp),
         month = month(timestamp),
         season = case_when(
           month %in% 10:12 ~ "Fall",
           month %in%  1:3  ~ "Winter",
           month %in%  4:6  ~ "Spring",
           TRUE ~ "Summer")) |> 
  group_by(hour, season) |> 
  summarise(across(everything(), c(mean = mean, sd = sd)))
```

```{r}
o2 <- ggplot(flux_s, aes(hour, flux3o2_mean, color = season)) + 
  geom_line() +
  geom_pointrange(aes(ymin = flux3o2_mean - flux3o2_sd,
                      ymax = flux3o2_mean + flux3o2_sd),
                  size = 0.1,
                  position = position_dodge(width = 0.5)) +
  geom_hline(yintercept = 0) +
  ylab("O2 Flux [mmol/m2/h]")

par <- ggplot(flux_s, aes(hour, par_mean, color = season)) +
  geom_line()

par / o2
```


```{r}
h <- ggplot(flux_h, aes(hour, flux3ph_mean)) + 
  geom_line() +
  #geom_pointrange(aes(ymin = flux3o2_mean - flux3o2_sd,
  #                    ymax = flux3o2_mean + flux3o2_sd)) +
  geom_hline(yintercept = 0) +
  ylab("H+ Flux [mmol/m2/h]")

par <- ggplot(flux_h, aes(hour, par_mean)) +
  geom_line()

par / h
```


```{r}
o2 <- ggplot(flux_s, aes(hour, flux3ph_mean, color = season)) + 
  geom_line() +
  geom_pointrange(aes(ymin = flux3ph_mean - flux3ph_sd,
                      ymax = flux3ph_mean + flux3ph_sd),
                  size = 0.1,
                  position = position_dodge(width = 0.5)) +
  geom_hline(yintercept = 0) +
  ylab("H+ Flux [mmol/m2/h]")

par <- ggplot(flux_s, aes(hour, par_mean, color = season)) +
  geom_line()

par / o2
```