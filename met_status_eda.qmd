---
title: "Met and status data"
format: html
editor: source
---

```{r}
library(tidyverse)
library(arrow)
library(dygraphs)
library(suntools)

data_dir <- "data/processed/surface"
```

# Met data

```{r}
ds <- open_dataset(file.path(data_dir, "lecs_met.parquet"))
```

Dimensions

```{r}
names(ds)
nrow(ds)
```

```{r}
ds |> 
  summarize(time_min = min(timestamp), 
            time_max = max(timestamp) 
  ) |> 
  collect()
```

Duplicates?

```{r}
ds |> 
  group_by(timestamp) |> 
  summarize(n = n()) |> 
  filter(n > 1) |> 
  collect()
```

## PAR

PAR looks pretty questionable. 
Is noise clouds, electronic issues or something else.

TODO: Calibrate by codeployment with radiometer.
TODO: Denoise?
TODO: Test system (codeployment will be initial test)

```{r}
ds |> 
  select(timestamp, PAR) |> 
  collect() |> 
  dygraph()
```


calculate potential insolation curve to help correct timestamps

```{r}
crds <- matrix(c(-70.7003, 41.51875), nrow = 1)

# calculate predicted par from solar azimuth
pred_par <- function(crds, timestamp) {
  altitude <- solarpos(crds, timestamp)[,2]
  altitude <- replace(altitude, altitude <= 0, 0)
  insolation = sin(altitude * pi / 180)
  par = 0.45 * insolation * 4.6 * 1000
  par
}    

par_15m <- ds |> 
  mutate(timestamp = floor_date(timestamp, "15min")) |>
  group_by(timestamp) |>
  summarize(par = mean(PAR)) |>
  ungroup() |>
  collect() |> 
  mutate(#timestamp = timestamp + 3600 * 4, # time offset
         par = par/117 - 25, # approximate par calibration umol/m2/s
         pred_par = pred_par(crds, timestamp))

par_15m |> 
  select(timestamp, par, pred_par) |> 
  collect() |> 
  dygraph(main = "LECS Surface PAR vs predicted PAR",
          ylab = "PAR [µmol m<sup>-2</sup> s<sup>-1</sup>]") |> 
  dyRangeSelector()
```

```{r}
par_15m |> 
  select(timestamp, par, pred_par) |> 
  filter(timestamp > "2024-08-18",
         timestamp < "2024-08-25") |> 
  collect() |> 
  pivot_longer(cols = c(par, pred_par), names_to = "type", values_to = "par") |> 
  ggplot(aes(timestamp, par, color = type)) + 
    geom_line()
  dygraph(main = "LECS Surface PAR vs predicted PAR",
          ylab = "PAR [µmol m<sup>-2</sup> s<sup>-1</sup>]") |> 
  dyRangeSelector()

```

## Wind

```{r}
ds |> 
  select(timestamp, wind_speed) |> 
  collect() |> 
  dygraph()
```


```{r}
ds |> 
  select(timestamp, wind_dir) |> 
  collect() |> 
  dygraph()
```

# Status

```{r}
status <- open_dataset(file.path(data_dir, "lecs_status.parquet"))
```

Dimensions

```{r}
names(status)
nrow(status)
```

```{r}
status |> 
  summarize(time_min = min(timestamp), 
            time_max = max(timestamp) 
  ) |> 
  collect()
```

Duplicates?

```{r}
ds |> 
  group_by(timestamp) |> 
  summarize(n = n()) |> 
  filter(n > 1) |> 
  collect()
```

minute average

```{r}
st_min <- status |> 
  mutate(timestamp = floor_date(timestamp, "minutes")) |> 
  group_by(timestamp) |> 
  summarise(across(!adv_timestamp,
                   ~ mean(.x, na.rm = TRUE))) |> 
  ungroup()
```

## Battery    

```{r}
st_min |> 
  select(timestamp, bat) |> 
  collect() |> 
  dygraph()
```

daily average

```{r}
status |> 
  mutate(timestamp = floor_date(timestamp, "day")) |> 
  group_by(timestamp) |> 
  summarise(across(!adv_timestamp,
                   ~ mean(.x, na.rm = TRUE))) |> 
  ungroup() |> 
  select(timestamp, bat) |> 
  collect() |> 
  dygraph()
```

## IMU

```{r}
st_min |> 
  select(timestamp, pitch, roll) |> 
  collect() |> 
  dygraph() |> 
  dyRangeSelector()
```

bad IMU data

```{r}
status |> 
  select(timestamp, pitch, roll, heading) |> 
  filter(timestamp > "2023-10-05 00:00:00",
         timestamp < "2023-10-07 00:00:00") |> 
  collect() |> 
  dygraph() |> 
  dyRangeSelector()
```

Tag points where lander is reoriented

```{r}
library(dplyr)
library(slider)

detect_mean_changes <- function(df, ts_col, window_size = 10, threshold = 2) {
  df %>%
    mutate(
      running_mean = slide_dbl({{ts_col}}, 
                              mean,
                              .before = floor(window_size/2),
                              .after = floor(window_size/2),
                              .complete = FALSE),
      mean_change = running_mean - lag(running_mean),
      is_change_point = abs(mean_change) > threshold
    )
}

lander_change <- st_min |> 
  select(timestamp, roll) |> 
  collect() |> 
  detect_mean_changes(roll)
```

```{r}
lander_change |> 
  select(timestamp, roll, is_change_point) |> 
  mutate(is_change_point = is_change_point * 200) |> 
  dygraph()
```

soundspeed

```{r}
st_min |> 
  select(timestamp, soundspeed) |> 
  collect() |> 
  dygraph() |> 
  dyRangeSelector()
```

